"""Functions and class for simulating a trainable ANN"""
#import numpy as np
import tensorflow as tf #pylint: disable = E0401

LEARNING_RATE = 0.1
SEED = 1
MAX_TRAINING_ROUNDS = 20000
BATCH_SIZE = 200

class NeuralNetwork:
    """Class representing a trainable NeuralNetwork with one hidden layer"""
    def __init__(self, input_matrix, output_vector):
        self.input_matrix = input_matrix
        self.output_vector = output_vector
        self.input_nodes = input_matrix.shape[1]
        self.hidden_nodes = int((self.input_nodes + 1))
        self.tf_graph = TensorFlowGraph(self.input_nodes, self.hidden_nodes)

    def train(self):
        """Train neural net synapses by feeding forward then adjusting by back propagation"""
        print('Starting training session')
        for epoch in range(MAX_TRAINING_ROUNDS):
            mean_error = 0
            total_batch = 1#int(self.input_matrix.shape[0]/BATCH_SIZE)
            for i in range(total_batch):
                batch_x, batch_y = self.batch_creator(i, BATCH_SIZE)
                cost = self.tf_graph.run_with_cost(batch_x, batch_y)
                mean_error += cost / total_batch
            if epoch % 1000 == 0:
                print("Epoch:", (epoch), "cost =", mean_error, flush=True)
        print('Training complete')

    def feed(self, input_matrix):
        """Calculate outputs for given input_matrix"""
        return self.tf_graph.run_for_output(input_matrix)

    def batch_creator(self, batch_number, batch_size):
        """Create batch with random samples and return appropriate format"""
        start = batch_number * batch_size
        #end = (batch_number + 1) * batch_size
        batch_x = self.input_matrix[start:]#end
        batch_y = self.output_vector[start:]#end
        return batch_x, batch_y


class TensorFlowGraph():
    """Wrapper class for TensorFlow libraries to build the computation graph
    and maintain a reference to the session and variables used for training """
    def __init__(self, input_nodes, hidden_nodes):
        self.input_2_hidden_synapse = tf.Variable(tf.random_normal([input_nodes,
                                                                    hidden_nodes], seed=SEED))
        self.hidden_2_output_synapse = tf.Variable(tf.random_normal([hidden_nodes,
                                                                     1], seed=SEED))
        self.input_placeholder = tf.placeholder(tf.float32, [None, input_nodes])
        self.output_placeholder = tf.placeholder(tf.float32, [None, 1])
        hidden_biases = tf.Variable(tf.random_normal([hidden_nodes],
                                                     seed=SEED))
        output_bias = tf.Variable(tf.random_normal([1], seed=SEED))
        hidden_layer = tf.add(tf.matmul(self.input_placeholder,
                                        self.input_2_hidden_synapse), hidden_biases)
        hidden_layer = tf.nn.sigmoid(hidden_layer)
        self.output_layer = tf.matmul(hidden_layer,
                                      self.hidden_2_output_synapse) + output_bias
        cost_function, optimizer = self.build_cost_and_optimizer(self.output_layer)
        self.cost_function = cost_function
        self.optimizer = optimizer
        self.sess = tf.Session()
        tf.global_variables_initializer().run(session=self.sess)

    def build_cost_and_optimizer(self, output_layer):
        """Define and build tf variables representing cost/error function and
        training/optimizer function"""
        cost_function = tf.reduce_mean((output_layer - self.output_placeholder)
                                       * (output_layer - self.output_placeholder))
        optimizer = tf.train.GradientDescentOptimizer(LEARNING_RATE).minimize(cost_function)
        return cost_function, optimizer

    def run_with_cost(self, inputs, outputs):
        """Run used for training, returns output of the cost_function"""
        f_dict = {self.input_placeholder: inputs, self.output_placeholder: outputs}
        _, cost = self.sess.run([self.optimizer, self.cost_function], feed_dict=f_dict)
        return cost

    def run_for_output(self, inputs):
        """Run used to generate output in evalutaion, returns output generated by network"""
        f_dict = {self.input_placeholder: inputs}
        output = self.sess.run(self.output_layer, feed_dict=f_dict)
        return output
